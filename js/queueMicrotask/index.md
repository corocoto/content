---
title: "`queueMicrotask`"
authors:
  - corocoto
tags:
  - doka
---

## Кратко

Браузерное API, которое может быть использовано для конвертации синхронного кода в асинхронный.

## Пример

```js
queueMicrotask(() => {
    console.log('Хэй, я выполнюсь асинхронно благодаря queueMicrotask');
});
```

## Как пишется

`queueMicrotask`:
* Принимает функцию, которая будет передана в очередь микрозадач;
* Всегда возвращает `undefined`.

## Как понять

Код выше схож со сценарием использования [`setTimeout`](/js/settimeout/). Оба выполнят код асинхронно:

```js
setTimeout(() => {
    console.log('hey i am executed asychronously by setTimeout');
}, 0);
```

Так в чем же принципиальная разница между ними?

`queueMicrotask` добавляет переданную функцию в _очередь микрозадач_. Функции в этой очереди выполняются одна за другой (_FIFO: First in First Out_) — когда текущая функция выполнилась, запускается следующая функция в очереди.

Микрозадачи будут выполнены только после того, как текущий _[стек вызовов](/js/async-in-js/#stek-vyzovov)_ окажется пустым, но перед выполнением _[цикла событий](/js/async-in-js/#cikl-sobytiy)_.

Если вернуться к сравнению с `setTimeout`, то передаваемые функции этого API будут относится к разряду _макрозадач_. Каждая из них будет взята из очереди задач, после того как управление передастся циклу событий.

Поэтому, если вызвать `queueMicrotask` после `setTimeout`, или наоборот - функция, переданная в `queueMicrotask` начнёт свое исполнение первой.

### Когда использовать

Не существует чётких правил по использованию `queueMicrotask`. Но его всегда можно использовать для запуска фрагмента кода, без приостановки текущего выполнения.

Представим, что есть массив, который будет содержать список значений. После того, как значение будет добавлено - происходит сортировка. Предположим, что это необходимо для ускорения поиска.

```js
const list = [];

function addAndSort(value) {
  list.push(value);
  list.sort();
}
```

Выглядит неплохо, но есть одно "НО".

Представим, что у нас есть поисковая строка. Получается, что поиск элемента будет выполняться всякий раз, когда пользователь вводит что-то в эту строку. Таким образом, обработчик события будет вызван после передачи управления в цикл событий, а сортировка данных будет блокироваться выполнением синхронного кода.

Давайте воспользуемся `queueMicrotask` и исправим эту проблему:
```js
function addAndSort(value) {
  list.push(value);
  queueMicrotask(() => {
    list.sort();
  });
}
```
