---
title: "`queueMicrotask`"
description: "Брат `setTimeout`, или как добавить синхронную функцию в очередь микрозадач"
authors:
  - corocoto
keywords:
  - macrotasks
  - microtasks
  - sync-to-async
tags:
  - doka
---

## Кратко

Браузерное API, которое выполняет переданный код асинхронно.

## Пример

```js
queueMicrotask(() => {
    console.log('Хэй, я выполнюсь асинхронно благодаря queueMicrotask');
});
```

## Как пишется

`queueMicrotask`:
* Принимает функцию, которая будет передана в очередь микрозадач;
* Является процедурой, поэтому всегда возвращает `undefined`.

## Как понять

Код выше схож со сценарием использования [`setTimeout`](/js/settimeout/). Оба выполнят код асинхронно:

```js
setTimeout(() => {
    console.log('Хэй, я выполнюсь асинхронно благодаря setTimeout');
}, 0);
```

Так в чем же принципиальная разница между ними?

`queueMicrotask` добавляет переданную функцию в _очередь микрозадач_. Функции в этой очереди выполняются одна за другой (_FIFO: First in First Out_) — когда текущая функция выполнилась, запускается следующая функция в очереди.

Микрозадачи будут выполнены только после того, как текущий _[стек вызовов](/js/async-in-js/#stek-vyzovov)_ окажется пустым, но перед выполнением _[цикла событий](/js/async-in-js/#cikl-sobytiy)_.

Если вернуться к сравнению с `setTimeout`, то передаваемые функции этого API будут относится к разряду _макрозадач_. Каждая из них будет взята из очереди задач, после того как управление передастся циклу событий.

Поэтому, если вызвать `queueMicrotask` после `setTimeout`, или наоборот - функция, переданная в `queueMicrotask`, начнёт своё исполнение первой.

Рассмотрим микро и макрозадачи чуть детальней:

![схема событийного цикла](/js/queueMicrotask/images/event-loop-schema.png)

JavaScript имеет в своём арсенале различные _виды очередей_, а также _стек вызовов_. Давайте кратко разберём необходимый минимум, который поможет разобраться с процессом работы:
* _Стек вызовов_ — является контейнером для выполнения синхронных операций
* _Очередь микрозадач_ — является контейнером для выполнения асинхронных операций, имеющих высокий приоритет;
* _Очередь макрозадач_ — является контейнером для выполнения асинхронных операций с низким приоритетом.

Что же, кажется, самое время рассмотреть процесс работы между этими самыми элементами:
* Первый, кто начинает процесс выполнения — стек вызовов;
* После того, как JavaScript убеждается, в том, что стек пуст — ответственность переходит к очереди микрозадач;
* Процесс выполнения продолжается до тех пор, пока не станет ясно, что очередь опустела или не требуется каких-либо выполнений. Как только это произойдёт — в игру вступает очередь макрозадач;
* Очередь макрозадач является завершающим этапом. После того как список в нем станет пустым — все повторяется по новой.

### Когда использовать

Не существует чётких правил по использованию `queueMicrotask`. Но его всегда можно использовать для запуска фрагмента кода, без приостановки текущего выполнения.

Представим, что есть массив, который будет содержать список значений. После того, как значение будет добавлено - происходит сортировка. Предположим, что это необходимо для ускорения поиска.

```js
const list = [];

function addAndSort(value) {
  list.push(value);
  list.sort();
}
```

Выглядит неплохо, но есть одно "НО".

Представим, что у нас есть поисковая строка. Получается, что поиск элемента будет выполняться всякий раз, когда пользователь вводит что-то в эту строку. Таким образом, обработчик события будет вызван после передачи управления в цикл событий, а сортировка данных будет блокироваться выполнением синхронного кода.

Давайте воспользуемся `queueMicrotask` и исправим эту проблему:
```js
function addAndSort(value) {
  list.push(value);
  queueMicrotask(() => {
    list.sort();
  });
}
```
